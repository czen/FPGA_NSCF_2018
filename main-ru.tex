\documentclass[utf8]{psta}% 
% Пожалуйста, уточните классификация Вашей статьи согласно УДК, ББК и MSC
\subjclass[UDC]{004.4'422}
\subjclass[BBC]{32.972.11}
\subjclass[2010]{68N20}

% Заглавие работы
\title[Статическая классификация программ для ПЛИС]{Метод статической классификации участков программы для отображения на ПЛИС}
%\title[]{} % или с коротким вариантом для колонтитула

% Фамилия, запятая, имя отчество автора
\author{Баглий, Антон Павлович}
% Организация, в которой выполнена статья или её часть автором
\address{Южный федеральный университет}
% Электронный адрес автора
\email{abagly@sfedu.ru}
% Какими грантами поддержана работа автора
\thanks{Данная работа была поддержана фондом РФФИ согласно исследовательскому проекту № 18-37-00179\textbackslash18}
%  краткая информация, в свободной форме  презентующая официальный статус автора, его научные интересы и достижения. 
\info{}
% фотография, позволяющая узнать автора в толпе участников любой конференции
%\image{}
\image{Bagly}
\orcid{0000-0001-9089-4164}    
% Аналогично для каждого из остальных авторов

% Пару строчек ключевых слов и фраз для поиска
\keywords{оптимизирующий компилятор, ПЛИС, высокоуровневый синтез}
\begin{abstract}
   Приводятся результаты продолжающегося исследования по поиску способ классификации участков высокоуровневой программы для отображения на ПЛИС. Приводятся данные применения разработанных метрик гнезд циклов на тестовых программах. Ставится задача более точной оценки времени работы и использования ресурсов высокоуровневой программой при ее отображении на ПЛИС. На основе имеющегося метода статического профилирования программы в высокоуровневом представлении строится алгоритм эмуляции абстрактной перенастраиваемой архитектуры с целью более точной оценки скорости работы схемы, построенной по выбранному участку программы. Для ускорения эмуляции используются известные методы создания репрезентативной выборки участков программы на основе вектора простых блоков.
\end{abstract}

% Все метаданные должны также присутствовать на английском языке, 
% заключённые в  \selectlanguage{english}...,\selectlanguage{russian}: 

\selectlanguage{english} 
% All the same in English 
\title[Static program classification for FPGA]{Technique for static classification of program fragments to be mapped onto FPGA}
% Last name, coma other names 
\author{Bagly, Anton Pavlovich}
% Organisation, where the work done
\address{Southern federal university}
% author email
\email{abagly@sfedu.ru}
% support notes
\thanks{This work was supported by RFBR according to research project № 18-37-00179\textbackslash18}
% Other information about author only on paper language 
%\info{} %
% author photo
%\image{}
%\orcid{}
% Repeat the same fore each of other authors
%
\begin{abstract}
 We present resutls of ongoing research to find ways of high-level program fragments classification for mapping onto FPGA. Results of applying developed loop nests metrics on test programs are presented. The problem of more precise approximation for high-level program running time and resource usage when mapped to FPGA  is stated. An algorithm emulating abstract reconfigurable architecture based on available static program profiling technique is built to aid in more precise approximation of future circuite performance based on selected program fragment. Known methods of creating representative set of program fragments for simulation based on basic block vectors are used to speed up the emulator.
\end{abstract}
\selectlanguage{russian} % Не забывайте отметить возврат на русский язык
% Для локального переключения на другой язык используйте команду 
% \foreignlanguage{english}{Text in English}

\begin{document}           
\maketitle   
%%%%%% Текст статьи может использовать 
\section*{Введение}

\section{Постановка задачи} 

Для эффективного отображения высокоуровневых программ на ПЛИС стоит задача поиска частей программы, выполнение которых на ПЛИС наиболее выгодно (приведет к наибольшему ускорению работы программы в целом при выполнении ограничений на имеющиеся ресурсы ПЛИС).
Эту задачу можно сформулировать как задачу классификации участков кода на классы:

\begin{itemize}
    \item Участки, эффективно выполняемые на ПЛИС
    \item Участки, выполнение которых на ПЛИС не выгодно.
\end{itemize}

Решение этой задачи возможно самыми разными путями, среди которых можно выделить следующие:

\begin{itemize}
    \item Поиск долго считаемых участков программы (особенно гнезд циклов), которые производят большой объем вычислений с ограниченным набором данных
    \item Поиск долго считаемых гнезд циклов, которые допускают конвейеризацию.
    \item Поиск участков программы (функций или срезов), выполнение которых отнимает большое время и отображение которых на ПЛИС возможно с учетом ограничений на ресурсы.
\end{itemize}

Для поиска таких участков программы можно использовать различные методы, применяемые в современных средах разработки, компиляторах высокоуровневых языков программирования и инструментах раработки для ПЛИС:

\begin{itemize}
    \item анализ потока данных
    \item статический анализ кода с вычислением метрик
    \item симуляция поведения программы
    \item профилирование во время выполнения
    \item низкоуровневая эмуляция процессора на программе
\end{itemize}

В этой работе приводятся результаты применения более поверхностного подхода, основанного на метриках, после чего ставится более сложная задача точной аппроксимации времени работы программы и используемых ресурсов при ее выполнении на абстрактной реконфигурируемой архитектуре с целью использовать полученные данные для классификации выбранных срезов программы на упомянутые два класса.

\section{методы решения}

\subsection{Поиск участков кода с выгодными метриками}

Метрики исходного кода являются популярным методом контроля качестве программного обеспечения. Чаще всего метрики применяются для формирования численных характеристик исходного кода, учитывающих его структуру. Для оценки их пригодности к решению поставленных нами задач был выбрана задача поиска гнезд циклов с выгодным соотношение объема вычислений к объему обрабатываемых данных.
Нами был проверен способ поиска гнезд циклов, у которых размерность гнезда превышает размерность массивов, к которым происходят обращения. Эта метрика была проверена на программах их бенчмарка CSTone \cite{Hara2009}, результаты приведены в табл. \ref{table:CHStoneSingularLoops}

\begin{table}
    \begin{tabular}{ | p{1.5cm} | p{2cm} | p{1cm} | p{6cm} |}
    \hline
    Программа & долго счит. гнезд циклов & из них отвечают критерию & особенности \\ \hline
    adpcm & 3 & 0 & нельзя заранее определить число итераций \\ \hline
    aes & 3 & 1 &  \\ \hline
    blowfish & 1 & 0 & цикл уже полностью развернут в исходном коде \\ \hline
    dfadd & 1 & 0 &  \\ \hline
    dfdiv & 1 & 0 &  \\ \hline
    dfmul & 1 & 0 &  \\ \hline
    dfsin & 1 & 0 &  \\ \hline
    gsm & 1 & 0 &  \\ \hline
    jpeg & 4 & 2 & нельзя заранее определить число итераций \\ \hline
    mips & 1 & 1 & нельзя заранее определить число итераций \\ \hline
    motion & 2 & 0 &  \\ \hline
    sha & 1 & 0 &  \\ \hline
    \end{tabular} 
    \caption{Результаты поиска специальных циклов в бенчмарках CHStone}
    \label{table:CHStoneSingularLoops}
\end{table}

Как видно из приведенных результатов, применение такой метрики на реальных программах осложнено многими факторами. И хотя в некоторых случаях такой поверхностный поиск дает результаты, в большинстве случаев найденные гнезда циклов оказываются не внутри горячих участков, определяемых профилированием во время выполнения, а значит не представляют интереса для ускорения.

\subsection{Статический анализ для оценки пригодности для ПЛИС}

В составе Оптимизирующей распараллеливающей системы \ref{OPS2018} был ранее разработан инструмент статического анализа \cite{2010}, предназначенный для оценки времени работы участков программы без ее запуска (статический профилировщик). Статическое профилирование может эффективно работать только для узкого класса программ. И хотя статический профилировщик способен приблизительно оценить время работы гнезда циклов и число операций записи в память в нем, это возможно только если число итераций циклов известно во время компиляции. Как видно из табл. \ref{table:CHStoneSingularLoops} во многих случаях нельзя во время компиляции определить число итераций цикла внутри долго считаемого гнезда.

Более развитым вариантом статического анализа программы является набор методов, основанных на частичных трансферных функциях \cite{PartialTransferFunctions}. На основе внутреннего представления ОРС и этих методов был ранее разрабоан алгоритм поиска псевдонимов \cite{Poluyan2010}. Время работы анализатора псевдонимов, основанного на данном методе оказывается чрезмерно большим для программ типичного объема. 

Поскольку указанный метод анализа кода проводит симуляцию выполнения программы (с некоторыми ограничениями), он подходит для более точной аппроксимации времени ее работы. Работа статического профилировщика основана на предположении, что операторы в исходной программе на выскоуровневом языке в определенной мере соответствуют инструкциям, выполняемым процессором при ее запуске после компиляции. Это предположение справедливо для привычной архитектуры универсального процессора, выполняющего линейный поток инструкций. Для реконфигурируемой архитектуры это предположение не верно и для прогноза времени работы схемы, созданной по высокоуровневой программе требуется определить характеристики построенных по ней конвейеров, например, построив сперва граф вычислений \cite{Steinberg2016}. Поскольку такой анализ сложен, увеличивает время компиляции и не позволяет анализировать всю программу целиком, то он в таком виде не подходит для быстрой оценки пригодности участков кода к отображению на ПЛИС.


\subsection{Быстрая аппроксимация времени и возможности выполнения на ПЛИС} 

Существуют методы оценки поведения программы за счет формирования вектора  простых блоков \cite{Sherwood2002}, анализ которого позволяет выбрать репрезентативный набор участков программы. Это такие участки (простые блоки), по результатам эмуляции работы которых можно аппроксимировать работу время работы программы целиком. Этот подход отличается малой зависимостью от архитектуры и используется для ускорения низкоуровневой эмуляции аппаратных архитектур при их тестировании на программах.

Суть работы данного метода в том, что при эмуляции работы программы детально выполняются только найденные репрезентативные участки, а остальная программа выполняется без учета особенностей целевой архитектуры.

Целесообразно использовать указанный способ ускорения эмуляции программы  для ускорения методов статического анализа.

Далее представлены результаты поиска способов применения описанный методов в различных комбинациях для эмирической проверки их точности и пригодности для анализа типичных программ.

\section{Полностью статический анализ}

Для проверки метода статического анализа, использующего векторы простых блоков, были реализованы следующие возможности:

\begin{itemize}
    \item Генерация вектора простых блоков при обходе управляющего графа программы c ограниченной эмуляцией ее выполнения.
    \item Использование результатов работы утилиты simpoint \cite{Simpoint2005} для выбора репрезентативных фрагментов
    \item статический анализ времени выполнения и использования памяти для репрезентативных блоков, основанный на статическом профилировщике
\end{itemize}

\begin{table}
    \begin{tabular}{ | p{1.5cm} | p{2cm} | p{1cm} | p{6cm} |}
    \hline
    Программа & время & аппроксимация & особенности \\ \hline
    РАЗДЕЛ В РАЗРАБОТКЕ
    \end{tabular} 
    \caption{Результаты статического анализа с использованием BBV}
    \label{table:CHStoneSingularLoops}
\end{table}

\subsection{Эмуляция абстрактной архитектуры}

Кроме статического анализа программы возможна непосредственная эмуляция выполнения целевой программы на некоей архитектуре с целью оценки характеристик ее работы.

При разработке архитектур центральных процессоров распространено использование эмуляторов архитектуры, которые позволяют протестировать работу процессора на любой программе и определить скорость выполнения, особенности работы с памятью и другие важные характеристики. 

Симуляция выполнения программы на ПЛИС тоже возможна, но не для высокоуровневой программы. В процессе разработки программы для ПЛИС всегда присутствуют этапы эмуляции ее выполнения (на разных уровнях представления) до непосредственной прошивки физического устройства. Это сложный процесс, опирающийся на описание конкретной архитектуры ПЛИС, для которой разрабатывается программа. Для получения более быстрого прогноза требуется эмуляция на более высоком уровне, возможно на уровне программы на высокоуровневом языке, еще до выбора целевого устройства.

Ранее проводились исследования, посвященные этой тематике, напр. \cite{Takamaeda-Yamazaki2014}. Но они направлены в большей мере на улучшение инструментов низкоуровневого синтеза на ПЛИС путем увеличения его гибкости (возможности синтезировать проект для ПЛИС с большим разбросом характеристик из одного низкоуровневого описания).

Предлагается разработка высокоуровневого эмулятора реконфигурируемой архитектуры, обладающего набором характеристик:

\begin{itemize}
    \item Возможность работы в двух режимах: детальной эмуляции с учетом выбранных характеристик эмулируемой архитектуры и ускоренном
    \item Работа с программой в высокоуровневом внутреннем представлении целевого языка или производном от него низкоуровневом представлении компилятора, но не в представлении низкоуровневого языка описания схем
    
\end{itemize}

Разрабатываемый эмулятор основывается на интерпретаторе узкого подмножества языка С, который при детальном анализе подсчитывает время выполнения с учетом доступных вычислительных модулей. Интерпретация основана на обходе управляющего графа по простым блокам и их выполнении в порядке, допускаемом инф. зависимостями. При этом для выполнения определенных операторов задействуются виртуальные вычислительные модули, количество и тип которых задается заранее как описание архитектуры.

Далее представлены результаты работы разрабатываемого эмулятора на тестовом наборе программ для сравнения с результатами полностью статического анализа.
  
\section{Результаты}

РАЗДЕЛ В РАЗРАБОТКЕ
   

%Проверяйте, пожалуйста (URL) в списке литературы \cite{PSTAmanual}!% ссылка на источник литературы
\section{}
\subsection{}
%\citеs{,,} % ссылка на несколько источников

%\begin{figure} % Never fix the place!
%\includegraphics{pic} % Без расширения, должно быть jpg, png или pdf
%%\includegraphics[width=10cm]{pic} % Если по ширине страницы
%\caption{}
%\label{}
%\end{figure}

%%%%% Нумерация библиографии в порядке цитирования, инициалы перд фамилией. 
% 
\bibliographystyle{amsalpha}
\bibliography{bibliography.bib}

\end{document}

