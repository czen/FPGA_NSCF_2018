\documentclass[utf8]{psta}% 
% Пожалуйста, уточните классификация Вашей статьи согласно УДК, ББК и MSC
\subjclass[UDC]{004.4'422}
\subjclass[BBC]{32.972.11}
\subjclass[2010]{68N20}

% Заглавие работы
\title[Статическая классификация программ для ПЛИС]{Метод статической классификации участков программы для отображения на ПЛИС}
%\title[]{} % или с коротким вариантом для колонтитула

% Фамилия, запятая, имя отчество автора
\author{Баглий, Антон Павлович}
% Организация, в которой выполнена статья или её часть автором
\address{Южный федеральный университет}
% Электронный адрес автора
\email{abagly@sfedu.ru}
% Какими грантами поддержана работа автора
\thanks{Данная работа была поддержана фондом РФФИ согласно исследовательскому проекту № 18-37-00179\textbackslash18}
%  краткая информация, в свободной форме  презентующая официальный статус автора, его научные интересы и достижения. 
\info{}
% фотография, позволяющая узнать автора в толпе участников любой конференции
%\image{}
\image{Bagly}
\orcid{0000-0001-9089-4164}    
% Аналогично для каждого из остальных авторов

% Пару строчек ключевых слов и фраз для поиска
\keywords{оптимизирующий компилятор, ПЛИС, высокоуровневый синтез}
\begin{abstract}
   Приводятся результаты продолжающегося исследования по поиску способ классификации участков высокоуровневой программы для отображения на ПЛИС. Приводятся данные применения разработанных метрик гнезд циклов на тестовых программах. Ставится задача более точной оценки времени работы и использования ресурсов высокоуровневой программой при ее отображении на ПЛИС. На основе имеющегося метода статического профилирования программы в высокоуровневом представлении строится алгоритм эмуляции абстрактной перенастраиваемой архитектуры с целью более точной оценки скорости работы схемы, построенной по выбранному участку программы. Для ускорения эмуляции используются известные методы создания репрезентативной выборки участков программы на основе вектора простых блоков.
\end{abstract}

% Все метаданные должны также присутствовать на английском языке, 
% заключённые в  \selectlanguage{english}...,\selectlanguage{russian}: 

\selectlanguage{english} 
% All the same in English 
\title[Static program classification for FPGA]{Technique for static classification of program fragments to be mapped onto FPGA}
% Last name, coma other names 
\author{Bagly, Anton Pavlovich}
% Organisation, where the work done
\address{Southern federal university}
% author email
\email{abagly@sfedu.ru}
% support notes
\thanks{This work was supported by RFBR according to research project № 18-37-00179\textbackslash18}
% Other information about author only on paper language 
%\info{} %
% author photo
%\image{}
%\orcid{}
% Repeat the same fore each of other authors
%
\begin{abstract}
 We present resutls of ongoing research to find ways of high-level program fragments classification for mapping onto FPGA. Results of applying developed loop nests metrics on test programs are presented. The problem of more precise approximation for high-level program running time and resource usage when mapped to FPGA  is stated. An algorithm emulating abstract reconfigurable architecture based on available static program profiling technique is built to aid in more precise approximation of future circuite performance based on selected program fragment. Known methods of creating representative set of program fragments for simulation based on basic block vectors are used to speed up the emulator.
\end{abstract}
\selectlanguage{russian} % Не забывайте отметить возврат на русский язык
% Для локального переключения на другой язык используйте команду 
% \foreignlanguage{english}{Text in English}

\begin{document}           
\maketitle   
%%%%%% Текст статьи может использовать 
\section*{Введение}

\section{Постановка задачи} 

Для эффективного отображения высокоуровневых программ на ПЛИС стоит задача поиска частей программы, выполнение которых на ПЛИС наиболее выгодно (приведет к наибольшему ускорению работы программы в целом при выполнении ограничений на имеющиеся ресурсы ПЛИС).
Эту задачу можно сформулировать как задачу классификации участков кода на классы:

\begin{itemize}
    \item Участки, эффективно выполняемые на ПЛИС
    \item Участки, выполнение которых на ПЛИС не выгодно.
\end{itemize}

Решение этой задачи возможно самыми разными путями, среди которых можно выделить следующие:

\begin{itemize}
    \item Поиск долго считаемых участков программы (особенно гнезд циклов), которые производят большой объем вычислений с ограниченным набором данных
    \item ...
\end{itemize}

Для поиска таких участков программы можно использовать различные методы, применяемые в современных средах разработки, компиляторах высокоуровневых языков программирования и инструментах раработки для ПЛИС:

\begin{itemize}
    \item анализ потока данных
    \item статический анализ кода с вычислением метрик
    \item симуляция поведения программы
    \item профилирование во время выполнения
    \item низкоуровневая эмуляция процессора на программе
\end{itemize}

В этой работе приводятся результаты применения более поверхностного подхода, основанного на метриках, после чего ставится более сложная задача точной аппроксимации времени работы программы и используемых ресурсов при ее выполнении на абстрактной реконфигурируемой архитектуре с целью использовать полученные данные для классификации выбранных срезов программы на упомянутые два класса.

\section{методы решения}

\subsection{Поиск участков кода с выгодными метриками}

Метрики программного обеспечения являются популярным методом контроля качестве программного обеспечения. Для оценки их пригодности к решению поставленных нами задач был выбрана задача поиска гнезд циклов с выгодным соотношение объема вычислений к объему обрабатываемых данных.
Нами был проверен способ поиска гнезд циклов, у которых размерность гнезда превышает размерность массивов, к которым происходят обращения. Эта метрика была проверена на программах их бенчмарка CSTone \cite{Hara2009}, результаты приведены в табл. \ref{table:CHStoneSingularLoops}

\begin{table}
    \begin{tabular}{ | p{1.5cm} | p{2cm} | p{1cm} | p{6cm} |}
    \hline
    Программа & долго счит. гнезд циклов & из них отвечают критерию & особенности \\ \hline
    adpcm & 3 & 0 & нельзя заранее определить число итераций \\ \hline
    aes & 3 & 1 &  \\ \hline
    blowfish & 1 & 0 & цикл уже полностью развернут в исходном коде \\ \hline
    dfadd & 1 & 0 &  \\ \hline
    dfdiv & 1 & 0 &  \\ \hline
    dfmul & 1 & 0 &  \\ \hline
    dfsin & 1 & 0 &  \\ \hline
    gsm & 1 & 0 &  \\ \hline
    jpeg & 4 & 2 & нельзя заранее определить число итераций \\ \hline
    mips & 1 & 1 & нельзя заранее определить число итераций \\ \hline
    motion & 2 & 0 &  \\ \hline
    sha & 1 & 0 &  \\ \hline
    \end{tabular} 
    \caption{Результаты поиска специальных циклов в бенчмарках CHStone}
    \label{table:CHStoneSingularLoops}
\end{table}

Как видно из приведенных результатов, применение такой метрики на реальных программах осложнено многими факторами. И хотя в некоторых случаях такой поверхностный поиск дает результаты, в большинстве случаев найденные гнезда циклов оказываются не внутри горячих участков, определяемых профилированием во время выполнения, а значит не представляют интереса для ускорения.

\subsection{Статический анализ для оценки пригодности для ПЛИС}

В составе Оптимизирующей распараллеливающей системы \ref{OPS2018} был ранее разработан инструмент статического анализа \cite{2010}, предназначенный для оценки времени работы участков программы без ее запуска (статический профилировщик). Статическое профилирование может эффективно работать только для узкого класса программ. И хотя статический профилировщик способен приблизительно оценить время работы гнезда циклов и число операций записи в память в нем, это возможно только если число итераций циклов известно во время компиляции. Как видно из табл. \ref{table:CHStoneSingularLoops} во многих случаях нельзя во время компиляции определить число итераций цикла внутри долго считаемого гнезда.

Более развитым вариантом статического анализа программы является набор методов, основанных на частичных трансферных функциях \cite{PartialTransferFunctions}. На основе внутреннего представления ОРС и этих методов был разрабоан алгоритм поиска псевдонимов \cite{Poluyan2010}. Время работы анализатора псевдонимов, основанного на данном методе оказывается чрезмерно большим для программ типичного объема.




\subsection{Быстрая аппроксимация времени выполнения и возможности выполнения на ПЛИС} 

\cite{Sherwood2002}

за счет:

\begin{itemize}
   \item  эмулятора на базе интерпретатора С, который бы подсчитывал время с учетом доступных вычислительных модулей. Интерпретатор должен работать за счет обхода управляющего графа по простым блокам и их выполнения в порядке, допускаемом инф. зависимостями. При этом для выполнения определенных операторов задействуются виртуальные вычислительные модули, количество и тип которых задается заранее.
   \item возможности указанного интерпретатора пройти вперед до определенного блока кода (для ускорения). Можно пытаться задействовать LLVM и считать простые блоки в нем, лишь бы получилось сделать fast-forward до нужного блока
   \item использования simpoints для хорошей оценки времени работы на эмулируемой архитектуре
   \item вероятность того, что проект не поместится на ПЛИС, можно оценить по результатам работы интерпретатора (сколько виртуальных вычислителей было задействовано, сколько можно еще задействовать)
\end{itemize}

\subsection{эмуляция абстрактной архитектуры}

В связи перечисленными выше сложностями становится вопрос о непосредственной эмуляции выполнения целевой программы на некоей архитектуре с целью оценки характеристик ее работы.

При разработке архитектур центральных процессоров распространено использование эмуляторов архитектуры, которые позволяют протестировать работу процессора на любой программе и определить скорость выполнения, особенности работы с памятью и другие важные характеристики. 

Симуляция выполнения программы на ПЛИС тоже возможна, но не для высокоуровневой программы. В процессе разработки программы для ПЛИС всегда присутствуют этапы эмуляции ее выполнения (на разных уровнях представления) до непосредственной прошивки физического устройства. Это сложный процесс, опирающийся на описание конкретной архитектуры ПЛИС, для которой разрабатывается программа. Для получения более быстрого прогноза требуется эмуляция на более высоком уровне, возможно на уровне программы на высокоуровневом языке, еще до выбора целевого устройства.

Ранее проводились исследования, посвященные этой тематике, напр. \cite{Takamaeda-Yamazaki2014}. Но они направлены в большей мере на улучшение инструментов низкоуровневого синтеза на ПЛИС путем увеличения его гибкости (возможности синтезировать проект для ПЛИС с большим разбросом характеристик из одного низкоуровневого описания).

Мы предлагаем разработку высокоуровневого эмулятора реконфигурируемой архитектуры, обладающего набором характеристик:

\begin{itemize}
    \item Возможность работы в двух режимах: детальной эмуляции с учетом выбранных характеристик эмулируемой архитектуры и ускоренном
    \item Работа с программой в высокоуровневом внутреннем представлении целевого языка или производном от него низкоуровневом представлении компилятора, но не в представлении низкоуровневого языка описания схем
    
\end{itemize}
  
  
\section{РЕЗУЛЬТАТЫ}

РАЗДЕЛ В РАЗРАБОТКЕ
   

%Проверяйте, пожалуйста (URL) в списке литературы \cite{PSTAmanual}!% ссылка на источник литературы
\section{}
\subsection{}
%\citеs{,,} % ссылка на несколько источников

%\begin{figure} % Never fix the place!
%\includegraphics{pic} % Без расширения, должно быть jpg, png или pdf
%%\includegraphics[width=10cm]{pic} % Если по ширине страницы
%\caption{}
%\label{}
%\end{figure}

%%%%% Нумерация библиографии в порядке цитирования, инициалы перд фамилией. 
% 
\bibliographystyle{amsalpha}
\bibliography{bibliography.bib}

\end{document}

